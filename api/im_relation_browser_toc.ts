// Code generated by protoc-gen-browser. DO NOT EDIT.
// version:
// 	protoc-gen-browser v0.0.103<br />
// 	protoc             v4.25.3<br />
// source: api/im_relation.proto<br />

export interface LogicError{
	code: number;
	msg: string;
}

export class AcceptGroupApplyReq{
	group_id: string = ''
	user_id: string = ''
	toJSON(){
		let tmp = {}
		if(this.group_id){
			tmp["group_id"]=this.group_id
		}
		if(this.user_id){
			tmp["user_id"]=this.user_id
		}
		return tmp
	}
}
export class AcceptGroupApplyResp{
	fromOBJ(_obj:Object){
	}
}
export class AcceptGroupInviteReq{
	group_id: string = ''
	toJSON(){
		let tmp = {}
		if(this.group_id){
			tmp["group_id"]=this.group_id
		}
		return tmp
	}
}
export class AcceptGroupInviteResp{
	fromOBJ(_obj:Object){
	}
}
export class AcceptMakeFriendReq{
	user_id: string = ''
	toJSON(){
		let tmp = {}
		if(this.user_id){
			tmp["user_id"]=this.user_id
		}
		return tmp
	}
}
export class AcceptMakeFriendResp{
	fromOBJ(_obj:Object){
	}
}
export class DelFriendReq{
	user_id: string = ''
	toJSON(){
		let tmp = {}
		if(this.user_id){
			tmp["user_id"]=this.user_id
		}
		return tmp
	}
}
export class DelFriendResp{
	fromOBJ(_obj:Object){
	}
}
export class GroupApplyReq{
	group_id: string = ''
	toJSON(){
		let tmp = {}
		if(this.group_id){
			tmp["group_id"]=this.group_id
		}
		return tmp
	}
}
export class GroupApplyResp{
	fromOBJ(_obj:Object){
	}
}
export class GroupInviteReq{
	group_id: string = ''
	user_id: string = ''
	toJSON(){
		let tmp = {}
		if(this.group_id){
			tmp["group_id"]=this.group_id
		}
		if(this.user_id){
			tmp["user_id"]=this.user_id
		}
		return tmp
	}
}
export class GroupInviteResp{
	fromOBJ(_obj:Object){
	}
}
export class GroupMembersReq{
	//hex(sha256(join(sort([userid1+"_"+duty+"_"+name,userid2+"_"+duty+"_"+name]),",")))
	current_hash: string = ''
	group_id: string = ''
	toJSON(){
		let tmp = {}
		if(this.current_hash){
			tmp["current_hash"]=this.current_hash
		}
		if(this.group_id){
			tmp["group_id"]=this.group_id
		}
		return tmp
	}
}
export class GroupMembersResp{
	update: boolean = false//if the current_hash is same,this field is false
	members: Array<RelationInfo|null>|null = null//if the current_hash is same,this field is empty
	fromOBJ(obj:Object){
		if(obj["update"]){
			this.update=obj["update"]
		}
		if(obj["members"] && obj["members"].length>0){
			this.members=new Array<RelationInfo|null>()
			for(let value of obj["members"]){
				if(value){
					let tmp=new RelationInfo()
					tmp.fromOBJ(value)
					this.members.push(tmp)
				}else{
					this.members.push(null)
				}
			}
		}
	}
}
export class KickGroupReq{
	group_id: string = ''
	user_id: string = ''
	toJSON(){
		let tmp = {}
		if(this.group_id){
			tmp["group_id"]=this.group_id
		}
		if(this.user_id){
			tmp["user_id"]=this.user_id
		}
		return tmp
	}
}
export class KickGroupResp{
	fromOBJ(_obj:Object){
	}
}
export class LeaveGroupReq{
	group_id: string = ''
	toJSON(){
		let tmp = {}
		if(this.group_id){
			tmp["group_id"]=this.group_id
		}
		return tmp
	}
}
export class LeaveGroupResp{
	fromOBJ(_obj:Object){
	}
}
export class MakeFriendReq{
	user_id: string = ''
	toJSON(){
		let tmp = {}
		if(this.user_id){
			tmp["user_id"]=this.user_id
		}
		return tmp
	}
}
export class MakeFriendResp{
	fromOBJ(_obj:Object){
	}
}
export class RefuseGroupApplyReq{
	group_id: string = ''
	user_id: string = ''
	toJSON(){
		let tmp = {}
		if(this.group_id){
			tmp["group_id"]=this.group_id
		}
		if(this.user_id){
			tmp["user_id"]=this.user_id
		}
		return tmp
	}
}
export class RefuseGroupApplyResp{
	fromOBJ(_obj:Object){
	}
}
export class RefuseGroupInviteReq{
	group_id: string = ''
	toJSON(){
		let tmp = {}
		if(this.group_id){
			tmp["group_id"]=this.group_id
		}
		return tmp
	}
}
export class RefuseGroupInviteResp{
	fromOBJ(_obj:Object){
	}
}
export class RefuseMakeFriendReq{
	user_id: string = ''
	toJSON(){
		let tmp = {}
		if(this.user_id){
			tmp["user_id"]=this.user_id
		}
		return tmp
	}
}
export class RefuseMakeFriendResp{
	fromOBJ(_obj:Object){
	}
}
export class RelationInfo{
	target: string = ''
	target_type: string = ''//user or group
	name: string = ''
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	duty: number = 0//only when the group's member use this field,0-normal,1-system owner,2-owner,3-admin
	fromOBJ(obj:Object){
		if(obj["target"]){
			this.target=obj["target"]
		}
		if(obj["target_type"]){
			this.target_type=obj["target_type"]
		}
		if(obj["name"]){
			this.name=obj["name"]
		}
		if(obj["duty"]){
			this.duty=obj["duty"]
		}
	}
}
export class RelationsReq{
	//hex(sha256(join(sort(["user_"+userid1+"_"+name,"group_"+groupid1+"_"+name,"user_"+userid2+"_"+name]),",")))
	current_hash: string = ''
	toJSON(){
		let tmp = {}
		if(this.current_hash){
			tmp["current_hash"]=this.current_hash
		}
		return tmp
	}
}
export class RelationsResp{
	update: boolean = false//if the current_hash is same,this field is false
	relations: Array<RelationInfo|null>|null = null//if the current_hash is same,this field is empty
	fromOBJ(obj:Object){
		if(obj["update"]){
			this.update=obj["update"]
		}
		if(obj["relations"] && obj["relations"].length>0){
			this.relations=new Array<RelationInfo|null>()
			for(let value of obj["relations"]){
				if(value){
					let tmp=new RelationInfo()
					tmp.fromOBJ(value)
					this.relations.push(tmp)
				}else{
					this.relations.push(null)
				}
			}
		}
	}
}
export class UpdateDutyInGroupReq{
	user_id: string = ''
	group_id: string = ''
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	new_duty: number = 0
	toJSON(){
		let tmp = {}
		if(this.user_id){
			tmp["user_id"]=this.user_id
		}
		if(this.group_id){
			tmp["group_id"]=this.group_id
		}
		if(this.new_duty){
			tmp["new_duty"]=this.new_duty
		}
		return tmp
	}
}
export class UpdateDutyInGroupResp{
	fromOBJ(_obj:Object){
	}
}
export class UpdateNameInGroupReq{
	group_id: string = ''
	new_name: string = ''
	toJSON(){
		let tmp = {}
		if(this.group_id){
			tmp["group_id"]=this.group_id
		}
		if(this.new_name){
			tmp["new_name"]=this.new_name
		}
		return tmp
	}
}
export class UpdateNameInGroupResp{
	fromOBJ(_obj:Object){
	}
}
export class UpdateUserRelationNameReq{
	target: string = ''
	target_type: string = ''
	new_name: string = ''
	toJSON(){
		let tmp = {}
		if(this.target){
			tmp["target"]=this.target
		}
		if(this.target_type){
			tmp["target_type"]=this.target_type
		}
		if(this.new_name){
			tmp["new_name"]=this.new_name
		}
		return tmp
	}
}
export class UpdateUserRelationNameResp{
	fromOBJ(_obj:Object){
	}
}
//timeout's unit is millisecond,it will be used when > 0
function call(timeout: number,url: string,opts: Object,error: (arg: LogicError)=>void,success: (arg: Object)=>void){
	let tid: number|null = null
	if(timeout>0){
		const c = new AbortController()
		opts["signal"] = c.signal
		tid = setTimeout(()=>{c.abort()},timeout)
	}
	let ok=false
	fetch(url,opts)
	.then(r=>{
		ok=r.ok
		if(r.ok){
			return r.json()
		}
		return r.text()
	})
	.then(d=>{
		if(!ok){
			throw d
		}
		success(d)
	})
	.catch(e=>{
		if(e instanceof Error){
			error({code:-1,msg:e.message})
		}else if(e.length>0 && e[0]=='{' && e[e.length-1]=='}'){
			error(JSON.parse(e))
		}else{
			error({code:-1,msg:e})
		}
	})
	.finally(()=>{
		if(tid){
			clearTimeout(tid)
		}
	})
}
const _WebPathRelationMakeFriend: string ="/im.relation/make_friend";
const _WebPathRelationAcceptMakeFriend: string ="/im.relation/accept_make_friend";
const _WebPathRelationRefuseMakeFriend: string ="/im.relation/refuse_make_friend";
const _WebPathRelationGroupInvite: string ="/im.relation/group_invite";
const _WebPathRelationAcceptGroupInvite: string ="/im.relation/accept_group_invite";
const _WebPathRelationRefuseGroupInvite: string ="/im.relation/refuse_group_invite";
const _WebPathRelationGroupApply: string ="/im.relation/group_apply";
const _WebPathRelationAcceptGroupApply: string ="/im.relation/accept_group_apply";
const _WebPathRelationRefuseGroupApply: string ="/im.relation/refuse_group_apply";
const _WebPathRelationDelFriend: string ="/im.relation/del_friend";
const _WebPathRelationLeaveGroup: string ="/im.relation/leave_group";
const _WebPathRelationKickGroup: string ="/im.relation/kick_group";
const _WebPathRelationRelations: string ="/im.relation/relations";
const _WebPathRelationGroupMembers: string ="/im.relation/group_members";
const _WebPathRelationUpdateUserRelationName: string ="/im.relation/update_user_relation_name";
const _WebPathRelationUpdateNameInGroup: string ="/im.relation/update_name_in_group";
const _WebPathRelationUpdateDutyInGroup: string ="/im.relation/update_duty_in_group";
//ToC means this is for users
export class RelationBrowserClientToC {
	constructor(host: string){
		if(!host || host.length==0){
			throw "RelationBrowserClientToC's host missing"
		}
		this.host=host
	}
	//timeout's unit is millisecond,it will be used when > 0
	make_friend(header: Object,req: MakeFriendReq,timeout: number,error: (arg: LogicError)=>void,success: (arg: MakeFriendResp)=>void){
		if(!header){
			header={}
		}
		header["Content-Type"] = "application/json"
		call(timeout,this.host+_WebPathRelationMakeFriend,{method:"POST",headers:header,body:JSON.stringify(req)},error,function(arg: Object){
			let r=new MakeFriendResp()
			r.fromOBJ(arg)
			success(r)
		})
	}
	//timeout's unit is millisecond,it will be used when > 0
	accept_make_friend(header: Object,req: AcceptMakeFriendReq,timeout: number,error: (arg: LogicError)=>void,success: (arg: AcceptMakeFriendResp)=>void){
		if(!header){
			header={}
		}
		header["Content-Type"] = "application/json"
		call(timeout,this.host+_WebPathRelationAcceptMakeFriend,{method:"POST",headers:header,body:JSON.stringify(req)},error,function(arg: Object){
			let r=new AcceptMakeFriendResp()
			r.fromOBJ(arg)
			success(r)
		})
	}
	//timeout's unit is millisecond,it will be used when > 0
	refuse_make_friend(header: Object,req: RefuseMakeFriendReq,timeout: number,error: (arg: LogicError)=>void,success: (arg: RefuseMakeFriendResp)=>void){
		if(!header){
			header={}
		}
		header["Content-Type"] = "application/json"
		call(timeout,this.host+_WebPathRelationRefuseMakeFriend,{method:"POST",headers:header,body:JSON.stringify(req)},error,function(arg: Object){
			let r=new RefuseMakeFriendResp()
			r.fromOBJ(arg)
			success(r)
		})
	}
	//timeout's unit is millisecond,it will be used when > 0
	group_invite(header: Object,req: GroupInviteReq,timeout: number,error: (arg: LogicError)=>void,success: (arg: GroupInviteResp)=>void){
		if(!header){
			header={}
		}
		header["Content-Type"] = "application/json"
		call(timeout,this.host+_WebPathRelationGroupInvite,{method:"POST",headers:header,body:JSON.stringify(req)},error,function(arg: Object){
			let r=new GroupInviteResp()
			r.fromOBJ(arg)
			success(r)
		})
	}
	//timeout's unit is millisecond,it will be used when > 0
	accept_group_invite(header: Object,req: AcceptGroupInviteReq,timeout: number,error: (arg: LogicError)=>void,success: (arg: AcceptGroupInviteResp)=>void){
		if(!header){
			header={}
		}
		header["Content-Type"] = "application/json"
		call(timeout,this.host+_WebPathRelationAcceptGroupInvite,{method:"POST",headers:header,body:JSON.stringify(req)},error,function(arg: Object){
			let r=new AcceptGroupInviteResp()
			r.fromOBJ(arg)
			success(r)
		})
	}
	//timeout's unit is millisecond,it will be used when > 0
	refuse_group_invite(header: Object,req: RefuseGroupInviteReq,timeout: number,error: (arg: LogicError)=>void,success: (arg: RefuseGroupInviteResp)=>void){
		if(!header){
			header={}
		}
		header["Content-Type"] = "application/json"
		call(timeout,this.host+_WebPathRelationRefuseGroupInvite,{method:"POST",headers:header,body:JSON.stringify(req)},error,function(arg: Object){
			let r=new RefuseGroupInviteResp()
			r.fromOBJ(arg)
			success(r)
		})
	}
	//timeout's unit is millisecond,it will be used when > 0
	group_apply(header: Object,req: GroupApplyReq,timeout: number,error: (arg: LogicError)=>void,success: (arg: GroupApplyResp)=>void){
		if(!header){
			header={}
		}
		header["Content-Type"] = "application/json"
		call(timeout,this.host+_WebPathRelationGroupApply,{method:"POST",headers:header,body:JSON.stringify(req)},error,function(arg: Object){
			let r=new GroupApplyResp()
			r.fromOBJ(arg)
			success(r)
		})
	}
	//timeout's unit is millisecond,it will be used when > 0
	accept_group_apply(header: Object,req: AcceptGroupApplyReq,timeout: number,error: (arg: LogicError)=>void,success: (arg: AcceptGroupApplyResp)=>void){
		if(!header){
			header={}
		}
		header["Content-Type"] = "application/json"
		call(timeout,this.host+_WebPathRelationAcceptGroupApply,{method:"POST",headers:header,body:JSON.stringify(req)},error,function(arg: Object){
			let r=new AcceptGroupApplyResp()
			r.fromOBJ(arg)
			success(r)
		})
	}
	//timeout's unit is millisecond,it will be used when > 0
	refuse_group_apply(header: Object,req: RefuseGroupApplyReq,timeout: number,error: (arg: LogicError)=>void,success: (arg: RefuseGroupApplyResp)=>void){
		if(!header){
			header={}
		}
		header["Content-Type"] = "application/json"
		call(timeout,this.host+_WebPathRelationRefuseGroupApply,{method:"POST",headers:header,body:JSON.stringify(req)},error,function(arg: Object){
			let r=new RefuseGroupApplyResp()
			r.fromOBJ(arg)
			success(r)
		})
	}
	//timeout's unit is millisecond,it will be used when > 0
	del_friend(header: Object,req: DelFriendReq,timeout: number,error: (arg: LogicError)=>void,success: (arg: DelFriendResp)=>void){
		if(!header){
			header={}
		}
		header["Content-Type"] = "application/json"
		call(timeout,this.host+_WebPathRelationDelFriend,{method:"POST",headers:header,body:JSON.stringify(req)},error,function(arg: Object){
			let r=new DelFriendResp()
			r.fromOBJ(arg)
			success(r)
		})
	}
	//timeout's unit is millisecond,it will be used when > 0
	leave_group(header: Object,req: LeaveGroupReq,timeout: number,error: (arg: LogicError)=>void,success: (arg: LeaveGroupResp)=>void){
		if(!header){
			header={}
		}
		header["Content-Type"] = "application/json"
		call(timeout,this.host+_WebPathRelationLeaveGroup,{method:"POST",headers:header,body:JSON.stringify(req)},error,function(arg: Object){
			let r=new LeaveGroupResp()
			r.fromOBJ(arg)
			success(r)
		})
	}
	//timeout's unit is millisecond,it will be used when > 0
	kick_group(header: Object,req: KickGroupReq,timeout: number,error: (arg: LogicError)=>void,success: (arg: KickGroupResp)=>void){
		if(!header){
			header={}
		}
		header["Content-Type"] = "application/json"
		call(timeout,this.host+_WebPathRelationKickGroup,{method:"POST",headers:header,body:JSON.stringify(req)},error,function(arg: Object){
			let r=new KickGroupResp()
			r.fromOBJ(arg)
			success(r)
		})
	}
	//timeout's unit is millisecond,it will be used when > 0
	relations(header: Object,req: RelationsReq,timeout: number,error: (arg: LogicError)=>void,success: (arg: RelationsResp)=>void){
		if(!header){
			header={}
		}
		header["Content-Type"] = "application/json"
		call(timeout,this.host+_WebPathRelationRelations,{method:"POST",headers:header,body:JSON.stringify(req)},error,function(arg: Object){
			let r=new RelationsResp()
			r.fromOBJ(arg)
			success(r)
		})
	}
	//timeout's unit is millisecond,it will be used when > 0
	group_members(header: Object,req: GroupMembersReq,timeout: number,error: (arg: LogicError)=>void,success: (arg: GroupMembersResp)=>void){
		if(!header){
			header={}
		}
		header["Content-Type"] = "application/json"
		call(timeout,this.host+_WebPathRelationGroupMembers,{method:"POST",headers:header,body:JSON.stringify(req)},error,function(arg: Object){
			let r=new GroupMembersResp()
			r.fromOBJ(arg)
			success(r)
		})
	}
	//timeout's unit is millisecond,it will be used when > 0
	update_user_relation_name(header: Object,req: UpdateUserRelationNameReq,timeout: number,error: (arg: LogicError)=>void,success: (arg: UpdateUserRelationNameResp)=>void){
		if(!header){
			header={}
		}
		header["Content-Type"] = "application/json"
		call(timeout,this.host+_WebPathRelationUpdateUserRelationName,{method:"POST",headers:header,body:JSON.stringify(req)},error,function(arg: Object){
			let r=new UpdateUserRelationNameResp()
			r.fromOBJ(arg)
			success(r)
		})
	}
	//timeout's unit is millisecond,it will be used when > 0
	update_name_in_group(header: Object,req: UpdateNameInGroupReq,timeout: number,error: (arg: LogicError)=>void,success: (arg: UpdateNameInGroupResp)=>void){
		if(!header){
			header={}
		}
		header["Content-Type"] = "application/json"
		call(timeout,this.host+_WebPathRelationUpdateNameInGroup,{method:"POST",headers:header,body:JSON.stringify(req)},error,function(arg: Object){
			let r=new UpdateNameInGroupResp()
			r.fromOBJ(arg)
			success(r)
		})
	}
	//timeout's unit is millisecond,it will be used when > 0
	update_duty_in_group(header: Object,req: UpdateDutyInGroupReq,timeout: number,error: (arg: LogicError)=>void,success: (arg: UpdateDutyInGroupResp)=>void){
		if(!header){
			header={}
		}
		header["Content-Type"] = "application/json"
		call(timeout,this.host+_WebPathRelationUpdateDutyInGroup,{method:"POST",headers:header,body:JSON.stringify(req)},error,function(arg: Object){
			let r=new UpdateDutyInGroupResp()
			r.fromOBJ(arg)
			success(r)
		})
	}
	private host: string
}

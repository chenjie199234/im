// Code generated by protoc-gen-browser. DO NOT EDIT.
// version:
// 	protoc-gen-browser v0.0.110<br />
// 	protoc             v4.25.3<br />
// source: api/im_match.proto<br />

export interface LogicError{
	code: number;
	msg: string;
}

export class ActivitiesReq{
	lan: string = ''
	toJSON(){
		let tmp = {}
		if(this.lan){
			tmp["lan"]=this.lan
		}
		return tmp
	}
}
export class ActivitiesResp{
	infos: Array<ActivityInfo|null>|null = null
	fromOBJ(obj:Object){
		if(obj["infos"] && obj["infos"].length>0){
			this.infos=new Array<ActivityInfo|null>()
			for(let value of obj["infos"]){
				if(value){
					let tmp=new ActivityInfo()
					tmp.fromOBJ(value)
					this.infos.push(tmp)
				}else{
					this.infos.push(null)
				}
			}
		}
	}
}
export class ActivityInfo{
	name: string = ''
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	min: number = 0
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	max: number = 0
	fromOBJ(obj:Object){
		if(obj["name"]){
			this.name=obj["name"]
		}
		if(obj["min"]){
			this.min=obj["min"]
		}
		if(obj["max"]){
			this.max=obj["max"]
		}
	}
}
export class CancelReq{
	toJSON(){
		let tmp = {}
		return tmp
	}
}
export class CancelResp{
	fromOBJ(_obj:Object){
	}
}
export class CitiesReq{
	lan: string = ''
	toJSON(){
		let tmp = {}
		if(this.lan){
			tmp["lan"]=this.lan
		}
		return tmp
	}
}
export class CitiesResp{
	infos: Array<CityInfo|null>|null = null
	fromOBJ(obj:Object){
		if(obj["infos"] && obj["infos"].length>0){
			this.infos=new Array<CityInfo|null>()
			for(let value of obj["infos"]){
				if(value){
					let tmp=new CityInfo()
					tmp.fromOBJ(value)
					this.infos.push(tmp)
				}else{
					this.infos.push(null)
				}
			}
		}
	}
}
export class CityInfo{
	name: string = ''
	regions: Array<string>|null = null
	fromOBJ(obj:Object){
		if(obj["name"]){
			this.name=obj["name"]
		}
		if(obj["regions"] && obj["regions"].length>0){
			this.regions=obj["regions"]
		}
	}
}
export class DoReq{
	lan: string = ''
	city: string = ''
	regions: Array<string>|null = null
	activities: Array<string>|null = null
	toJSON(){
		let tmp = {}
		if(this.lan){
			tmp["lan"]=this.lan
		}
		if(this.city){
			tmp["city"]=this.city
		}
		if(this.regions && this.regions.length>0){
			tmp["regions"]=this.regions
		}
		if(this.activities && this.activities.length>0){
			tmp["activities"]=this.activities
		}
		return tmp
	}
}
export class DoResp{
	fromOBJ(_obj:Object){
	}
}
export class StatusReq{
	toJSON(){
		let tmp = {}
		return tmp
	}
}
export class StatusResp{
	lan: string = ''
	city: string = ''
	regions: Array<string>|null = null
	activities: Array<string>|null = null
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	status: number = 0//0-depend on the fields up(empty:not in matching,not empty:in matching),>0-matched timestamp(unit seconds)
	matched_region: string = ''
	matched_activity: string = ''
	fromOBJ(obj:Object){
		if(obj["lan"]){
			this.lan=obj["lan"]
		}
		if(obj["city"]){
			this.city=obj["city"]
		}
		if(obj["regions"] && obj["regions"].length>0){
			this.regions=obj["regions"]
		}
		if(obj["activities"] && obj["activities"].length>0){
			this.activities=obj["activities"]
		}
		if(obj["status"]){
			this.status=obj["status"]
		}
		if(obj["matched_region"]){
			this.matched_region=obj["matched_region"]
		}
		if(obj["matched_activity"]){
			this.matched_activity=obj["matched_activity"]
		}
	}
}
//timeout's unit is millisecond,it will be used when > 0
function call(timeout: number,url: string,opts: Object,error: (arg: LogicError)=>void,success: (arg: Object)=>void){
	let tid: number|null = null
	if(timeout>0){
		const c = new AbortController()
		opts["signal"] = c.signal
		tid = setTimeout(()=>{c.abort()},timeout)
	}
	let ok=false
	fetch(url,opts)
	.then(r=>{
		ok=r.ok
		if(r.ok){
			return r.json()
		}
		return r.text()
	})
	.then(d=>{
		if(!ok){
			throw d
		}
		success(d)
	})
	.catch(e=>{
		if(e instanceof Error){
			error({code:-1,msg:e.message})
		}else if(e.length>0 && e[0]=='{' && e[e.length-1]=='}'){
			error(JSON.parse(e))
		}else{
			error({code:-1,msg:e})
		}
	})
	.finally(()=>{
		if(tid){
			clearTimeout(tid)
		}
	})
}
const _WebPathMatchStatus: string ="/im.match/status";
const _WebPathMatchDo: string ="/im.match/do";
const _WebPathMatchCancel: string ="/im.match/cancel";
const _WebPathMatchActivities: string ="/im.match/activities";
const _WebPathMatchCities: string ="/im.match/cities";
//ToC means this is for users
export class MatchBrowserClientToC {
	constructor(host: string){
		if(!host || host.length==0){
			throw "MatchBrowserClientToC's host missing"
		}
		this.host=host
	}
	//timeout's unit is millisecond,it will be used when > 0
	status(header: Object,req: StatusReq,timeout: number,error: (arg: LogicError)=>void,success: (arg: StatusResp)=>void){
		if(!header){
			header={}
		}
		header["Content-Type"] = "application/json"
		call(timeout,this.host+_WebPathMatchStatus,{method:"POST",headers:header,body:JSON.stringify(req)},error,function(arg: Object){
			let r=new StatusResp()
			r.fromOBJ(arg)
			success(r)
		})
	}
	//timeout's unit is millisecond,it will be used when > 0
	do(header: Object,req: DoReq,timeout: number,error: (arg: LogicError)=>void,success: (arg: DoResp)=>void){
		if(!header){
			header={}
		}
		header["Content-Type"] = "application/json"
		call(timeout,this.host+_WebPathMatchDo,{method:"POST",headers:header,body:JSON.stringify(req)},error,function(arg: Object){
			let r=new DoResp()
			r.fromOBJ(arg)
			success(r)
		})
	}
	//timeout's unit is millisecond,it will be used when > 0
	cancel(header: Object,req: CancelReq,timeout: number,error: (arg: LogicError)=>void,success: (arg: CancelResp)=>void){
		if(!header){
			header={}
		}
		header["Content-Type"] = "application/json"
		call(timeout,this.host+_WebPathMatchCancel,{method:"POST",headers:header,body:JSON.stringify(req)},error,function(arg: Object){
			let r=new CancelResp()
			r.fromOBJ(arg)
			success(r)
		})
	}
	//timeout's unit is millisecond,it will be used when > 0
	activities(header: Object,req: ActivitiesReq,timeout: number,error: (arg: LogicError)=>void,success: (arg: ActivitiesResp)=>void){
		if(!header){
			header={}
		}
		header["Content-Type"] = "application/json"
		call(timeout,this.host+_WebPathMatchActivities,{method:"POST",headers:header,body:JSON.stringify(req)},error,function(arg: Object){
			let r=new ActivitiesResp()
			r.fromOBJ(arg)
			success(r)
		})
	}
	//timeout's unit is millisecond,it will be used when > 0
	cities(header: Object,req: CitiesReq,timeout: number,error: (arg: LogicError)=>void,success: (arg: CitiesResp)=>void){
		if(!header){
			header={}
		}
		header["Content-Type"] = "application/json"
		call(timeout,this.host+_WebPathMatchCities,{method:"POST",headers:header,body:JSON.stringify(req)},error,function(arg: Object){
			let r=new CitiesResp()
			r.fromOBJ(arg)
			success(r)
		})
	}
	private host: string
}

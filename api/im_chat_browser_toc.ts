// Code generated by protoc-gen-browser. DO NOT EDIT.
// version:
// 	protoc-gen-browser v0.0.110<br />
// 	protoc             v4.25.3<br />
// source: api/im_chat.proto<br />

export interface LogicError{
	code: number;
	msg: string;
}

export class AckReq{
	target: string = ''
	target_type: string = ''
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	msg_index: number = 0
	toJSON(){
		let tmp = {}
		if(this.target){
			tmp["target"]=this.target
		}
		if(this.target_type){
			tmp["target_type"]=this.target_type
		}
		if(this.msg_index){
			tmp["msg_index"]=this.msg_index
		}
		return tmp
	}
}
export class AckResp{
	fromOBJ(_obj:Object){
	}
}
export class MsgInfo{
	//msg index start from 1
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	msg_index: number = 0
	//recall index start 1,0 means didn't recall
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	recall_index: number = 0
	msg: string = ''
	extra: string = ''
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	timestamp: number = 0
	sender: string = ''
	target: string = ''
	target_type: string = ''
	fromOBJ(obj:Object){
		if(obj["msg_index"]){
			this.msg_index=obj["msg_index"]
		}
		if(obj["recall_index"]){
			this.recall_index=obj["recall_index"]
		}
		if(obj["msg"]){
			this.msg=obj["msg"]
		}
		if(obj["extra"]){
			this.extra=obj["extra"]
		}
		if(obj["timestamp"]){
			this.timestamp=obj["timestamp"]
		}
		if(obj["sender"]){
			this.sender=obj["sender"]
		}
		if(obj["target"]){
			this.target=obj["target"]
		}
		if(obj["target_type"]){
			this.target_type=obj["target_type"]
		}
	}
}
export class PullReq{
	target: string = ''
	target_type: string = ''
	direction: string = ''
	//the response will include this index
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	start_msg_index: number = 0//if this is 0,means don't need to pull the msgs
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	start_recall_index: number = 0//if this is 0,means don't need to pull the recalls
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	count: number = 0
	toJSON(){
		let tmp = {}
		if(this.target){
			tmp["target"]=this.target
		}
		if(this.target_type){
			tmp["target_type"]=this.target_type
		}
		if(this.direction){
			tmp["direction"]=this.direction
		}
		if(this.start_msg_index){
			tmp["start_msg_index"]=this.start_msg_index
		}
		if(this.start_recall_index){
			tmp["start_recall_index"]=this.start_recall_index
		}
		if(this.count){
			tmp["count"]=this.count
		}
		return tmp
	}
}
export class PullResp{
	msgs: Array<MsgInfo|null>|null = null
	//Warning!!!map's key's type is uint32,be careful of sign(+) and overflow
	//Warning!!!map's value's type is uint32,be careful of sign(+) and overflow
	recalls: Map<number,number>|null = null
	fromOBJ(obj:Object){
		if(obj["msgs"] && obj["msgs"].length>0){
			this.msgs=new Array<MsgInfo|null>()
			for(let value of obj["msgs"]){
				if(value){
					let tmp=new MsgInfo()
					tmp.fromOBJ(value)
					this.msgs.push(tmp)
				}else{
					this.msgs.push(null)
				}
			}
		}
		if(obj["recalls"] && Object.keys(obj["recalls"]).length>0){
			this.recalls=new Map<number,number>()
			for(let key of Object.keys(obj["recalls"])){
				this.recalls.set(Number(key),obj["recalls"][key])
			}
		}
	}
}
export class RecallReq{
	target: string = ''
	target_type: string = ''
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	msg_index: number = 0
	toJSON(){
		let tmp = {}
		if(this.target){
			tmp["target"]=this.target
		}
		if(this.target_type){
			tmp["target_type"]=this.target_type
		}
		if(this.msg_index){
			tmp["msg_index"]=this.msg_index
		}
		return tmp
	}
}
export class RecallResp{
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	recall_index: number = 0
	fromOBJ(obj:Object){
		if(obj["recall_index"]){
			this.recall_index=obj["recall_index"]
		}
	}
}
export class SendReq{
	target: string = ''
	target_type: string = ''
	msg: string = ''
	extra: string = ''
	toJSON(){
		let tmp = {}
		if(this.target){
			tmp["target"]=this.target
		}
		if(this.target_type){
			tmp["target_type"]=this.target_type
		}
		if(this.msg){
			tmp["msg"]=this.msg
		}
		if(this.extra){
			tmp["extra"]=this.extra
		}
		return tmp
	}
}
export class SendResp{
	//msg index start from 1
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	msg_index: number = 0
	//unit: nanosecond
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	timestamp: number = 0
	fromOBJ(obj:Object){
		if(obj["msg_index"]){
			this.msg_index=obj["msg_index"]
		}
		if(obj["timestamp"]){
			this.timestamp=obj["timestamp"]
		}
	}
}
//timeout's unit is millisecond,it will be used when > 0
function call(timeout: number,url: string,opts: Object,error: (arg: LogicError)=>void,success: (arg: Object)=>void){
	let tid: number|null = null
	if(timeout>0){
		const c = new AbortController()
		opts["signal"] = c.signal
		tid = setTimeout(()=>{c.abort()},timeout)
	}
	let ok=false
	fetch(url,opts)
	.then(r=>{
		ok=r.ok
		if(r.ok){
			return r.json()
		}
		return r.text()
	})
	.then(d=>{
		if(!ok){
			throw d
		}
		success(d)
	})
	.catch(e=>{
		if(e instanceof Error){
			error({code:-1,msg:e.message})
		}else if(e.length>0 && e[0]=='{' && e[e.length-1]=='}'){
			error(JSON.parse(e))
		}else{
			error({code:-1,msg:e})
		}
	})
	.finally(()=>{
		if(tid){
			clearTimeout(tid)
		}
	})
}
const _WebPathChatSend: string ="/im.chat/send";
const _WebPathChatRecall: string ="/im.chat/recall";
const _WebPathChatAck: string ="/im.chat/ack";
const _WebPathChatPull: string ="/im.chat/pull";
//ToC means this is for users
export class ChatBrowserClientToC {
	constructor(host: string){
		if(!host || host.length==0){
			throw "ChatBrowserClientToC's host missing"
		}
		this.host=host
	}
	//timeout's unit is millisecond,it will be used when > 0
	send(header: Object,req: SendReq,timeout: number,error: (arg: LogicError)=>void,success: (arg: SendResp)=>void){
		if(!header){
			header={}
		}
		header["Content-Type"] = "application/json"
		call(timeout,this.host+_WebPathChatSend,{method:"POST",headers:header,body:JSON.stringify(req)},error,function(arg: Object){
			let r=new SendResp()
			r.fromOBJ(arg)
			success(r)
		})
	}
	//timeout's unit is millisecond,it will be used when > 0
	recall(header: Object,req: RecallReq,timeout: number,error: (arg: LogicError)=>void,success: (arg: RecallResp)=>void){
		if(!header){
			header={}
		}
		header["Content-Type"] = "application/json"
		call(timeout,this.host+_WebPathChatRecall,{method:"POST",headers:header,body:JSON.stringify(req)},error,function(arg: Object){
			let r=new RecallResp()
			r.fromOBJ(arg)
			success(r)
		})
	}
	//timeout's unit is millisecond,it will be used when > 0
	ack(header: Object,req: AckReq,timeout: number,error: (arg: LogicError)=>void,success: (arg: AckResp)=>void){
		if(!header){
			header={}
		}
		header["Content-Type"] = "application/json"
		call(timeout,this.host+_WebPathChatAck,{method:"POST",headers:header,body:JSON.stringify(req)},error,function(arg: Object){
			let r=new AckResp()
			r.fromOBJ(arg)
			success(r)
		})
	}
	//timeout's unit is millisecond,it will be used when > 0
	pull(header: Object,req: PullReq,timeout: number,error: (arg: LogicError)=>void,success: (arg: PullResp)=>void){
		if(!header){
			header={}
		}
		header["Content-Type"] = "application/json"
		call(timeout,this.host+_WebPathChatPull,{method:"POST",headers:header,body:JSON.stringify(req)},error,function(arg: Object){
			let r=new PullResp()
			r.fromOBJ(arg)
			success(r)
		})
	}
	private host: string
}
